/*
=======
клиент:
житель Ноттингема, который тащит бочку
это процесс

- житель (процесс) сам решает когда он в течении дня понесет бочку
 (сначала спит, потом несет, потом снова спит)
 (масштаб 1 час = 1 сек программы)
- выбор времени (сколько м-сек спать): рандом(0-24 000 мсек)
- понес...принес
-- говорит серверу - я принес бочку (шлет сообщение в сокет)
 (сервер внутри увеличивает счетчике бочек и отдает в ответ в сокет новое кол-во бочек)
-- житель узнает кол-во бочек, если бочек > 5 то "колокол" - setEvent("bell")
- вернулся, досыпает до конца суток (24 000 - сколько ранее спал)
.. цикл 5 раз повторяем ^^^ и завершаемся

=======
сервер: 
основной поток:
 - создает сокет
- принимает запрос 
- если запрос = (new barrel) то увеличивает колво бочек
  (если запрос другой то ничего не делает)

вспомогательные потоки: робин и товарищи 
- при старте сервера запускается 1 поток (Робин)
- поток ждет евента (белл)
- когда евент сработал (колокол позвонил) - робин идет к дубу какоето время (слип Х мсек)
-- забирает бочку (блокирует внутр перем сервера, уменьшает ее и разблокирует)
-- если бочек все равно осталось больше 5, то зовет друзей 
  (порождает еще 2 потока, таких же как он, только с флагом "друг" - чтоб они сами не звали друзей)
-- и запоминает сколько бочек осталось 
-- несет бочку домой (еще слип Х мсек)
-- решает надо ли идти еще раз
   -- помнит сколько бочек осталось, и привлеккал ли он друзей
   -- если бочек >= чем колво ходящих (он сам и друзья) - то надо снова идти
   -- если бочек меньше то надо снова ждать колокола (события)

- особенности потока-друга
   (такой же как и РОбин но с ограничениями)
-- умирает сам после окончания выполнения
-- знает сколько всего ходящих (общая переменная на сервере)
-- сам порождать потоки не может

сервер (основной поток) завершается когда (прошло 5 суток)
-- и завершает поток робина

=======
управляющая программа
- запускает сервер (1 шт)
- запускает клиентов (Х штук, задается при старте)





В цикле рабочей недели (5 дней) запускаются потоки для жителей, которые приносят бочку
приносит 1 бочку раз в день (увеличиваем перем числа бочек) ограничить число бочек через мьютекс
если бочонков становится больше 5, текущий житель с бочонком звонит в колокол на ветке дерева - эвент
нужен счетчик эвентов
робин снимает эвент, но пока он ходит могут прийти еще жители и снова поставить эвент
*/
// Функция потока клиента жителя
DWORD WINAPI VillagerThread(LPVOID lpParam)
{
    // Логика работы клиента
}

/* лес с дубом и отдельными потоками Робина и друзей
ожидает эвента звона в колокол
слышит звон (эвент) - идет и забирает 1 бочку(считаем как отдельные потоки на сервере - дубе)
предусмотреть время, которое нужно, чтобы отнести бочонок до убежища Робина - за это время могут подойти еще жители и бочек снова станет > 5
если после первого удара бочек >5, то зовем 2 друзей на помощь
(запуск 2 отдельных потоков, которым нужно то же время для условной транспортировки бочонка до базы Робина), которые активны, пока
не перетаскают все бочонки - уменьшение счетчика бочек
нужна переменные счетчики вызова робина и вызова друзей
В конце работы вывести статистику, сколько всего бочек было, и сколько раз Робин звал друзей на помощь
*/

// Функция потока Робина сервера
DWORD WINAPI RobinThread(LPVOID lpParam)
{
    // Логика работы Робина
}

// Функция потока друга Робина сервера
DWORD WINAPI FriendThread(LPVOID lpParam)
{
    // Логика работы друга Робина
}




int main()
{
    setlocale(LC_ALL, "Russian");

    // Инициализация семафоров и мьютекса
    HANDLE hMutex = CreateMutex(
        NULL,
        FALSE, 
        NULL
    );
    HANDLE hSemaphoreBarrels = CreateSemaphore(
        NULL, // атрибуты защиты
        0,    // начальное значение семафора                                          
        5,    // максимальное значение семафора
        NULL  // имя семафора
    );
    HANDLE hEventBell = CreateEventA(
        NULL,  // дескриптор не может наследоваться дочерними процессами.
        TRUE,  // создание события со сбросом вручную(True) или с автосбросом(False)
        TRUE,  // начальное состояние события
        "Bell" // имя объекта события
    );

    // Создание потоков для клиентов, Робина и его друзей

    // Ждем завершения работы потоков

    // Вывод статистики

    // Освобождение ресурсов

    return 0;
}

*/